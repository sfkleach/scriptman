package wrapper

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// Method represents the wrapper generation strategy.
type Method string

const (
	// MethodCompiled uses a compiled C program.
	MethodCompiled Method = "compiled"
	// MethodShell uses a shell script with hardlink.
	MethodShell Method = "shell"
	// MethodAuto automatically selects the best method.
	MethodAuto Method = "auto"
)

// SelectMethod determines which wrapper method to use.
func SelectMethod(requested Method) Method {
	if requested == MethodCompiled || requested == MethodShell {
		return requested
	}

	// Auto-detect: prefer compiled if cc is available.
	if _, err := exec.LookPath("cc"); err == nil {
		return MethodCompiled
	}

	return MethodShell
}

// CreateWrapper creates a wrapper executable using the specified method.
func CreateWrapper(method Method, name, interpreterPath, scriptPath, wrapperPath string) error {
	switch method {
	case MethodCompiled:
		return createCompiledWrapper(name, interpreterPath, scriptPath, wrapperPath)
	case MethodShell:
		return createShellWrapper(name, interpreterPath, scriptPath, wrapperPath)
	default:
		return fmt.Errorf("invalid wrapper method: %s", method)
	}
}

// createCompiledWrapper generates and compiles a C wrapper.
func createCompiledWrapper(name, interpreterPath, scriptPath, wrapperPath string) error {
	// Generate C source code with baked-in paths.
	cSource := fmt.Sprintf(`/* Generated by scriptman for: %s */
#include <unistd.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    /* Build new argv: [interpreter, script, original args..., NULL] */
    char **new_argv = malloc((argc + 2) * sizeof(char *));
    if (new_argv == NULL) return 1;
    
    new_argv[0] = "%s";
    new_argv[1] = "%s";
    for (int i = 1; i < argc; i++) {
        new_argv[i + 1] = argv[i];
    }
    new_argv[argc + 1] = NULL;
    
    execv("%s", new_argv);
    /* Only reached if execv fails */
    return 1;
}
`, name, interpreterPath, scriptPath, interpreterPath)

	// Create temporary C file.
	tmpDir, err := os.MkdirTemp("", "scriptman-compile-*")
	if err != nil {
		return fmt.Errorf("failed to create temp directory: %w", err)
	}
	defer os.RemoveAll(tmpDir)

	cFile := filepath.Join(tmpDir, name+".c")
	if err := os.WriteFile(cFile, []byte(cSource), 0644); err != nil {
		return fmt.Errorf("failed to write C source: %w", err)
	}

	// Ensure parent directory exists.
	if err := os.MkdirAll(filepath.Dir(wrapperPath), 0755); err != nil {
		return fmt.Errorf("failed to create wrapper directory: %w", err)
	}

	// Compile the C program.
	cmd := exec.Command("cc", "-o", wrapperPath, cFile)
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to compile wrapper: %w\nOutput: %s", err, output)
	}

	// Make executable.
	if err := os.Chmod(wrapperPath, 0755); err != nil {
		return fmt.Errorf("failed to set executable permissions: %w", err)
	}

	return nil
}

// createShellWrapper creates a shell script wrapper and hardlink.
func createShellWrapper(name, interpreterPath, scriptPath, wrapperPath string) error {
	// Generate shell script with baked-in paths.
	shellScript := fmt.Sprintf("#!/bin/sh\nexec %s %s \"$@\"\n", interpreterPath, scriptPath)

	// Determine shell script path (same directory as wrapper, with .sh extension).
	shellPath := wrapperPath + ".sh"

	// Ensure parent directory exists.
	if err := os.MkdirAll(filepath.Dir(wrapperPath), 0755); err != nil {
		return fmt.Errorf("failed to create wrapper directory: %w", err)
	}

	// Write shell script.
	if err := os.WriteFile(shellPath, []byte(shellScript), 0755); err != nil {
		return fmt.Errorf("failed to write shell script: %w", err)
	}

	// Get scriptman's own executable path.
	scriptmanPath, err := os.Executable()
	if err != nil {
		return fmt.Errorf("failed to get scriptman executable path: %w", err)
	}

	// Try to create hardlink to scriptman.
	if err := os.Link(scriptmanPath, wrapperPath); err != nil {
		// If hardlink fails (cross-filesystem), copy instead.
		if err := copyFile(scriptmanPath, wrapperPath); err != nil {
			return fmt.Errorf("failed to create wrapper (hardlink and copy both failed): %w", err)
		}
	}

	// Make wrapper executable.
	if err := os.Chmod(wrapperPath, 0755); err != nil {
		return fmt.Errorf("failed to set executable permissions: %w", err)
	}

	return nil
}

// copyFile copies a file from src to dst.
func copyFile(src, dst string) error {
	data, err := os.ReadFile(src)
	if err != nil {
		return fmt.Errorf("failed to read source file: %w", err)
	}

	if err := os.WriteFile(dst, data, 0755); err != nil {
		return fmt.Errorf("failed to write destination file: %w", err)
	}

	return nil
}

// Remove removes a wrapper and its associated files.
func Remove(method Method, wrapperPath string) error {
	var errors []string

	// Remove the wrapper itself.
	if err := os.Remove(wrapperPath); err != nil && !os.IsNotExist(err) {
		errors = append(errors, fmt.Sprintf("wrapper: %v", err))
	}

	// If shell method, also remove the .sh file.
	if method == MethodShell {
		shellPath := wrapperPath + ".sh"
		if err := os.Remove(shellPath); err != nil && !os.IsNotExist(err) {
			errors = append(errors, fmt.Sprintf("shell script: %v", err))
		}
	}

	if len(errors) > 0 {
		return fmt.Errorf("failed to remove wrapper: %s", strings.Join(errors, "; "))
	}

	return nil
}
