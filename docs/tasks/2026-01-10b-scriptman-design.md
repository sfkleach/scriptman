# Scriptman Design - Script Wrapper Tool, 2026-01-10

## Overview

Scriptman is a companion tool to execman that manages single-file scripts
downloaded from GitHub repositories.

**Platform scope**: Unix-only (Linux, macOS, BSD). No Windows support.

## Value Proposition

Scriptman provides for scripts what execman provides for binaries:

- **Central management** - Track installed scripts and their origins
- **Updates** - Re-fetch latest version from GitHub with one command
- **Clean removal** - Remove script and wrapper together
- **Name mapping** - Install `owner/repo/scripts/long-name.py` as just `tool`
- **Interpreter binding** - Specify interpreter at install time, not in shebang

## Relationship to Execman

| Tool | Purpose |
|------|---------|
| **execman** | Manages standalone executables downloaded from GitHub releases |
| **scriptman** | Manages scripts downloaded from GitHub, wrapped as executables |

Scriptman will use execman as a library, sharing infrastructure such as:
- GitHub API interaction
- Registry management patterns
- Configuration loading

The tools are separate repositories with separate binaries, keeping each
focused on a single responsibility.

## Core Command

```bash
scriptman install REPO PATH [--interpreter COMMAND] [--name NAME] [--into DIR]
```

- `REPO`: GitHub repository (e.g., `owner/repo` or `github.com/owner/repo`)
- `PATH`: Path to the script within the release or source archive
- `--interpreter`: Explicit interpreter command (guessed from extension if omitted)
- `--name`: Name for the wrapper (defaults to script filename without extension)
- `--into`: Target directory for wrapper (defaults to config default)

### Script Retrieval

Scripts are fetched from GitHub releases:

1. **Release asset**: If PATH matches a release asset, download directly
2. **Source archive**: Otherwise, download source tarball/zipball and extract

Path conventions:
- `scripts/myscript.py` - Look in release assets first, then source archive
- `source:scripts/myscript.py` - Explicitly from source archive
- `asset:myscript.py` - Explicitly from release assets

## Hybrid Wrapper Strategy

Scriptman uses a hybrid approach to create wrappers, avoiding runtime registry
lookups entirely. The strategy depends on whether a C compiler is available.

### Strategy A: Compiled C Binary (When `cc` Available)

Generate and compile a tiny C program with paths baked in:

```c
// Generated by scriptman for: myscript
#include <unistd.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    // Build new argv: [interpreter, script, original args..., NULL]
    char **new_argv = malloc((argc + 2) * sizeof(char *));
    new_argv[0] = "/usr/bin/python3";
    new_argv[1] = "/home/user/.local/share/scriptman/scripts/myscript.py";
    for (int i = 1; i < argc; i++) {
        new_argv[i + 1] = argv[i];
    }
    new_argv[argc + 1] = NULL;
    execv("/usr/bin/python3", new_argv);
    return 1;  // Only reached if execv fails.
}
```

Compile with: `cc -o myscript myscript.c`

Result: `~/.local/bin/myscript` (~16KB native binary, zero lookup overhead)

### Strategy B: Shell Script + Hardlink (No Compiler)

When no C compiler is available, use `/bin/sh` which POSIX guarantees:

1. **Generate shell script** with paths baked in:

```bash
#!/bin/sh
exec /usr/bin/python3 /home/user/.local/share/scriptman/scripts/myscript.py "$@"
```

2. **Save as**: `~/.local/bin/myscript.sh`

3. **Create hardlink**: `~/.local/bin/myscript` → `~/.local/bin/scriptman`

4. **Runner mode**: When scriptman is invoked as `myscript`, it looks for
   `myscript.sh` in the same directory and execs it.

### Comparison

| Aspect | Compiled C | Shell Script + Hardlink |
|--------|------------|------------------------|
| Runtime lookup | None (paths compiled in) | One stat + exec |
| Files created | 1 binary (~16KB) | 1 hardlink + 1 shell script |
| Dependencies | C compiler | /bin/sh (guaranteed) |
| Cross-filesystem | Just works | Requires copy fallback |

### Auto-Detection

Scriptman automatically selects the strategy:

```go
func selectStrategy() Strategy {
    if _, err := exec.LookPath("cc"); err == nil {
        return StrategyCompiled
    }
    return StrategyShellScript
}
```

Users can force a strategy with `--method compiled` or `--method shell`.

## Dual-Role Binary (Shell Script Strategy)

When using the shell script strategy, the `scriptman` binary serves two roles:

### Management Mode

When invoked as `scriptman`:

```bash
scriptman install owner/repo scripts/tool.py   # Install a script
scriptman list                                  # List installed scripts
scriptman remove myscript                       # Remove a script
scriptman check                                 # Verify all scripts
```

### Runner Mode

When invoked via a hardlink with any other name:

```bash
myscript arg1 arg2    # Executes the wrapped script
```

### Runner Logic

```go
func runScript(name string) {
    // Find our own location.
    self, _ := os.Executable()
    dir := filepath.Dir(self)
    
    // Look for companion shell script.
    shScript := filepath.Join(dir, name+".sh")
    if _, err := os.Stat(shScript); err == nil {
        args := append([]string{"sh", shScript}, os.Args[1:]...)
        syscall.Exec("/bin/sh", args, os.Environ())
    }
    
    // No script found.
    fmt.Fprintf(os.Stderr, "scriptman: no dispatch found for %s\n", name)
    os.Exit(1)
}
```

### Why Hardlinks Over Symlinks

- Some tools resolve symlinks and would see the original binary name
- Hardlinks are indistinguishable from "real" files
- `which myscript` returns the hardlink path, not "scriptman"

### Cross-Filesystem Limitation

Hardlinks don't work across filesystems. If the scriptman binary is on a
different filesystem than the target directory, scriptman copies itself
instead. This is detected and handled automatically.

## Registry Structure

The registry is used **only for management commands** (list, check, remove),
never for runtime dispatch. Runtime dispatch uses either compiled-in paths
(Strategy A) or companion shell scripts (Strategy B).

Location: `~/.config/scriptman/registry.json`

```json
{
    "schema_version": 1,
    "scripts": {
        "myscript": {
            "repo": "owner/repo",
            "source_path": "scripts/myscript.py",
            "local_script": "/home/user/.local/share/scriptman/scripts/myscript.py",
            "interpreter": "python3",
            "wrapper_path": "/home/user/.local/bin/myscript",
            "wrapper_method": "compiled",
            "installed_at": "2026-01-10T12:00:00Z",
            "version": "v1.2.3"
        }
    }
}
```

## Commands

### install

```bash
scriptman install REPO PATH [--interpreter CMD] [--name NAME] [--into DIR] [--method METHOD]
```

- Downloads script from GitHub release or source archive
- Stores script in `~/.local/share/scriptman/scripts/`
- Creates wrapper using selected strategy
- Records in registry

### list

```bash
scriptman list [--long] [--json]
```

### remove

```bash
scriptman remove <name> [--yes]
```

Removes wrapper, shell script (if any), downloaded script, and registry entry.

### check

```bash
scriptman check
```

Verifies:
- All wrappers exist
- All downloaded scripts exist
- Interpreters are available

### update

```bash
scriptman update [name] [--all]
```

Re-downloads script from GitHub (latest release) and recreates wrapper.

## Interpreter Detection

Priority order:

1. Explicit `--interpreter` flag
2. Shebang line in downloaded script (`#!/usr/bin/env python3`)
3. File extension mapping (`.py` → `python3`, `.rb` → `ruby`, `.sh` → `sh`)
4. Error if none can be determined

## Installation

Scriptman would be installed via execman:

```bash
execman install github.com/sfkleach/scriptman
```

Or via its own bootstrap script similar to execman's `install.sh`.

## Reserved Names

The name `scriptman` is reserved for the management CLI. Attempting to install
a script with this name should error:

```
Error: 'scriptman' is reserved for the management CLI.
       Choose a different name with --name.
```
